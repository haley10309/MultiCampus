클래스형 컴포넌트의 state 
    class Counter extends Component{
        constructor(props){ //컴포넌트의 생성자 메소드
            super(props); //현재 클래스형 컴포넌트가 상송받고 있는 리액트의 컴포넌트 클래스가 지닌 생성자 함수를 호출

        }
    }
    state = {
        number :0,
        name : ""
    }

함수형 컴포넌트 usestate
    const Say = () =>{
        const [message , setMessage] = useState('');
        const onClickEnter = () => setMessage("안녕하세요");
    }
    -useState는 객체가 아니어도 된다.

props : 부모 컴포넌트가 설정
state : 컴포넌트 자체적으로 지닌 값으로 컴포넌트 내부에서 값 업데이트가 가능

event handling : 사용자가 웹브라우저에서 dom요소들과 상호 작용하는 것
                이름은 카멜 표기법으로 작성 ex> onClick, onKeyUp
                컴포넌트 자체에서 함수 발생 못하고 dom 안에서만 사용 가능<div> <h1>
                
생명주기 메서드
    1. render() - render(){} : 컴포넌트 모양새를 정의 , 라이프 사이클 메서드 중 유일한 필수 메서드
                                setState 사용 안됨, 하려면 componentDidMount 처리해야 함.

    2. shouldComponentUpdate (nextProps, nextState){} : props 또는 state를 변경했을 때 ,리렌더링을 시작할 지 여부를 지정하는 메서드
                                                        리턴 값은 true ,false 
                                                        현재 props, state : this.props, this.state
                                                        새로 설정된 props, state : nextProps, nextState

    3. getSnapshotBeforeUpdate(prevProps, prevState){} : render 에서 만들어진 결과물이 브라우저에 실제로 반영되기 직전에 호출
                                                        
Hook : 함수현 컴포넌트에서도 useState ,useEffect 를 사용할 수 있게 하는 함수 
        컴포넌트 안에서만 호출할 수 있음. 테그안에서는 사용불가

        useEffect : 렌더링 될때마다 특정 작업을 수행하도록 설정할 수 있는 hook 
                    useEffect 안에 return 함수 : cleanup 함수 -> 렌더링 한 직후에 실행
        useReducer : useEffect보다 더 다양한 컴포넌트 상황에 따라 다양한 상태를 다른 값으로 업데이트해 주고 싶을 때 사용
                    function reducer(state, action){
                        switch(action.type){
                            case 'INCREMENT':
                                return {value : state.value + 1};
                            case 'DECREMENT':
                                return {value : state.value + 1};
                            default :
                                return state;
                        }
                    }
                    function Counter(props){
                        const [state, dispatch] = useReducer(reducer, [value:0]);
                            state : 현재 가리키고 있는 상태
                            dispatch : 액션을 발생시키는 함수
                            value : 리듀서의 기본값
                        return(
                            <div>
                                <button onClick ={() +> dispatch({type : 'INCREMENT'})}>+1</button>
                            </div>
                        )
                    }

        useMemo : 함수현 컴포넌트 내부에서 발생하는 연산을 최적화
        useCallback : 렌더링 최적화
        useRef : 특정 컴포넌트에 접근할 수 있는 객체를 사용하기 위한 훅
        

spa (single page application) : 한개의 페이지로 이루어진 어플리케이션

callback 함수 : 자바스크립트에서 비동기 작업을 할 때 가장 흔히 사용하는 방법 (권장하는 방법은 아님)

promise 함수 : 단점 보완 
            function increase(number){
                const promise = new promise ((resolve, reject) =>{})    
            }

async/await : promise를 더욱 쉽게 사용하기 위한 방법
                async function runTasks(){
                    try{
                        let result = await increase(0);
                        console.log(result);
                    }catch(e){
                        console.log(e);
                    }
                }